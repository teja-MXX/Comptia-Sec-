# üìå FEYNMAN STYLE NOTES ‚Äî HASHING, INTEGRITY & DIGITAL SIGNATURES

---

# 1. What is Integrity?

Integrity = making sure data has NOT been changed.

In cybersecurity, integrity is provided using hashing.

---

# 2. What is Hashing?

Hashing =

- A one-way cryptographic function
    
- Takes any input ‚Üí outputs a fixed-length message digest (hash)
    
- Cannot reverse it (no way to get original message from hash)
    

### Key properties:

1. One-way
    
    - No feasible method to reconstruct original data from the hash.
        
2. Deterministic
    
    - Same input ‚Üí always gives the same hash.
        
3. Fixed length
    
    - Input can be 1 word or 10 lakh words ‚Üí output size stays the same  
        (depends on algorithm: MD5 = 128 bits, SHA-1 = 160 bits, SHA-256 = 256 bits etc.)
        
4. Avalanche effect
    
    - Changing even one character or one bit drastically changes the output.
        

---

# 3. Why Does Hash Act Like a Digital Fingerprint?

Because:

- Every unique input ‚Üí produces a unique hash (ideally).
    
- Even tiny change ‚Üí output completely changes.
    
- So the hash represents exact state of the file/message.
    

---

# 4. Hashing Algorithms You Must Know

### A. MD5

- Output: 128-bit hash
    
- Very widely used in the past.
    
- PROBLEM: 128 bits = limited number of unique outputs.  
    ‚Üí Higher chance of collisions (two different inputs giving same hash).
    

So MD5 is considered broken and insecure.

---

### B. SHA Family (SHA-1, SHA-2, SHA-3)

### SHA-1

- Output: 160 bits
    
- Fewer collisions than MD5.
    
- Still considered weak today.
    

---

### SHA-2 Family

Includes:

- SHA-224 ‚Üí 224 bits
    
- SHA-256 ‚Üí 256 bits
    
- SHA-384 ‚Üí 384 bits
    
- SHA-512 ‚Üí 512 bits
    

More bits =  
‚Üí Larger output space  
‚Üí much fewer collisions  
‚Üí more secure

SHA-256 and SHA-512 are the global standards today.

---

### SHA-3

- Newer family.
    
- Output sizes same as SHA-2 (224‚Äì512 bits).
    
- But SHA-3 uses a different internal design and 120 rounds of computation (vs 64‚Äì80 for SHA-2).  
    ‚Üí Much stronger.
    

---

### C. RIPEMD

- RIPEMD-160 ‚Üí 160 bits (most used)
    
- Also has RIPEMD-256 and RIPEMD-320
    
- Open-source competitor to SHA
    
- Not as widely used.
    

---

### D. HMAC

Hash-based Message Authentication Code

- Provides integrity + authentication.
    
- Works by combining:
    
    - a secret key
        
    - a hashing algorithm (MD5, SHA-1, SHA-256 etc.)  
        ‚Üí Examples: HMAC-MD5, HMAC-SHA1, HMAC-SHA256
        

Use case:  
Verifying message origin + verifying it wasn‚Äôt modified.

---

# 5. Collisions

Collision = when two different inputs produce the same hash value.

- MD5 ‚Üí high collision chances
    
- SHA-1 ‚Üí possible
    
- SHA-256/512 ‚Üí extremely rare
    
- SHA-3 ‚Üí even stronger
    

Collisions are bad because they break integrity guarantees.

---

# 6. Digital Signatures (VERY IMPORTANT)

Digital signatures = encrypted hashes.

### Steps:

### (1) Sender creates hash of file/message

Example:  
Use SHA-1 ‚Üí get 160-bit digest.

### (2) Sender encrypts that hash using sender‚Äôs PRIVATE KEY

This encrypted hash = digital signature.

### (3) Sender sends:

- Original message
    
- Digital signature
    

### (4) Receiver verifies signature

Receiver:

1. Decrypts the digital signature using the sender‚Äôs public key  
    ‚Üí gets the original hash.
    
2. Re-hashes the received message using the same algorithm.
    
3. Compares both hashes.
    

If hashes match:

- Message has not been modified ‚Üí Integrity
    
- Only sender could have signed ‚Üí Non-repudiation  
    (Sender cannot claim ‚ÄúI didn‚Äôt send it‚Äù because only they have the private key)
    

---

# 7. Algorithms Used for Digital Signatures

### A. DSA (Digital Signature Algorithm)

- Used by US government.
    
- Works with 160-bit SHA digests.
    

### B. RSA

- Faster and widely used commercially.
    
- Used for:
    
    - digital signatures
        
    - encryption
        
    - key exchange
        
- Most common in real-world software.
    

### C. ECC / ECDSA

- Elliptic Curve version of digital signatures.
    
- Very efficient for low-power devices (mobiles, IoT).
    

---

# 8. Code Signing

- Developers must sign apps before uploading to App Store/Play Store.
    
- Steps:
    
    1. Hash the installer file.
        
    2. Encrypt the hash with developer‚Äôs private key.
        
    3. Attach this as a digital signature.
        

This guarantees:

- File wasn't modified
    
- File was published by a legit developer
    

---

# 9. Avalanche Demonstration (Important Concept)

Even changing one character (e.g., ‚Äúdefence‚Äù ‚Üí ‚Äúdefense‚Äù) makes the hash completely different.

This shows:

- Hashing is extremely sensitive to input
    
- Perfect for detecting tampering
    

---

# 10. Final Summary (Rapid Revision)

### Hashing = one-way function

- Outputs fixed-length digest
    
- Proves integrity
    
- Cannot be reversed
    
- Sensitive to tiny changes
    

### Algorithms

- MD5 (128-bit) ‚Üí insecure
    
- SHA-1 (160-bit) ‚Üí weak
    
- SHA-2 (256/512-bit) ‚Üí standard
    
- SHA-3 ‚Üí even stronger
    
- RIPEMD ‚Üí alternative
    
- HMAC ‚Üí integrity + authentication
    

### Digital Signatures

- Hash file
    
- Encrypt hash using private key
    
- Receiver verifies using public key  
    ‚Üí Provides integrity + non-repudiation
    

### Code Signing

- Same concept applied to executables / apps.